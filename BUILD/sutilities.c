/*+
 * File:	sutilities.c
 *
 * Purpose:	transforms the c data structures generated by the parser back into their binary form
 *
-*/

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>

#include <sys/param.h>
//#include <endian.h>

#include <stdio.h>
#include <stdlib.h>

#include "globals.h"
#include "sutilities.h"

#define LITTLE_END 0x41424344UL 
#define BIG_END    0x44434241UL
#define END_ORDER  ('ABCD')

// All nodes point to the firrst node in the list. First
// node points to itself.

SerializeBuffer *SerializeBufferAllocate(SerializeBuffer * current, int size){

    if(current == NULL) {

	current = (SerializeBuffer *)malloc(sizeof(SerializeBuffer));

	//TODO: check for NULL and throw print and exit
	if(size > MINSIZE) {
	    current->buffer = (uint8_t *)malloc(size);
	    current->bufferLen = size;
	} else {
	    current->buffer= (uint8_t*)malloc(MINSIZE);
	    current->bufferLen = MINSIZE;
        }
	current->totalLen = 0;
	current->curPos = 0;

	current->first = current;
	current->next = NULL;

	return current;

    } 

    // current != NULL

    int spaceLeft = current->bufferLen - current->curPos;
    if(spaceLeft > size){

	return current;

    } 

    // spaceLeft <= size

    //need to add another node of atleast MINSIZE or size if size>MINSIZE

    SerializeBuffer * newNode;
    newNode = (SerializeBuffer *)malloc(sizeof(SerializeBuffer));

    if(size>MINSIZE) {
	newNode->buffer= (uint8_t*)malloc(size);
	newNode->bufferLen = size;

    } else {
	newNode->buffer= (uint8_t*)malloc(MINSIZE);
	newNode->bufferLen = MINSIZE;

    }

    newNode -> next = NULL;
    current->next = newNode;
    newNode->curPos = 0;
    newNode->first = current->first;
    return newNode;

      
}

void writebufferInt64(SerializeBuffer * node,uint64_t val, int endianness)
{
    memcpy((void *) &(node->buffer[node->curPos]), (void *) &val, 8);
    if (((END_ORDER == LITTLE_END) && (endianness == BIGENDIAN)) || ((END_ORDER == BIG_END) && (endianness == !BIGENDIAN)))
    {
        uint8_t temp;
        temp = node->buffer[node->curPos];
        node->buffer[node->curPos] = node->buffer[node->curPos+7];
        node->buffer[node->curPos+7] = temp;

        temp = node->buffer[node->curPos+1];
        node->buffer[node->curPos+1] = node->buffer[node->curPos+6];
        node->buffer[node->curPos+6] = temp;

        temp = node->buffer[node->curPos+2];
        node->buffer[node->curPos+2] = node->buffer[node->curPos+5];
        node->buffer[node->curPos+5] = temp;

        temp = node->buffer[node->curPos+3];
        node->buffer[node->curPos+3] = node->buffer[node->curPos+4];
        node->buffer[node->curPos+4] = temp;
    }
    node->curPos += 8;
    node->first->totalLen += 8;

}

void writebufferInt48(SerializeBuffer * node,uint64_t val, int endianness)
{
    if (endianness == BIGENDIAN){
        node->buffer[node->curPos] = (val >> 40) & 0xFF;
        node->buffer[node->curPos+1] = (val >> 32) & 0xFF;
        node->buffer[node->curPos+2] = (val >> 24) & 0xFF;
        node->buffer[node->curPos+3] = (val >> 16) & 0xFF;
        node->buffer[node->curPos+4] = (val >> 8) & 0xFF;
        node->buffer[node->curPos+5] = val & 0xFF;
    } else {
        node->buffer[node->curPos+5] = (val >> 40) & 0xFF;
        node->buffer[node->curPos+4] = (val >> 32) & 0xFF;
        node->buffer[node->curPos+4] = (val >> 24) & 0xFF;
        node->buffer[node->curPos+2] = (val >> 16) & 0xFF;
        node->buffer[node->curPos+1] = (val >> 8) & 0xFF;
        node->buffer[node->curPos] = val & 0xFF;
    }
    node->curPos += 6;
    node->first->totalLen += 6;
}

void writebufferInt32(SerializeBuffer * node, uint32_t val, int endianness)
{  
    memcpy((void *) &(node->buffer[node->curPos]), (void *) &val, 4);
    if (((END_ORDER == LITTLE_END) && (endianness == BIGENDIAN)) || ((END_ORDER == BIG_END) && (endianness == !BIGENDIAN)))
    {
        uint8_t temp;
        temp = node->buffer[node->curPos];
        node->buffer[node->curPos] = node->buffer[node->curPos+3];
        node->buffer[node->curPos+3] = temp;

        temp = node->buffer[node->curPos+1];
        node->buffer[node->curPos+1] = node->buffer[node->curPos+2];
        node->buffer[node->curPos+2] = temp;
    }
    node->curPos += 4;
    node->first->totalLen += 4;

}

void writebufferInt24(SerializeBuffer * node,uint32_t val, int endianness)
{
    if (endianness == BIGENDIAN){
        node->buffer[node->curPos] = (val >> 16) & 0xFF;
        node->buffer[node->curPos+1] = (val >> 8) & 0xFF;
        node->buffer[node->curPos+2] = val & 0xFF;
    } else {
        node->buffer[node->curPos+2] = (val >> 16) & 0xFF;
        node->buffer[node->curPos+1] = (val >> 8) & 0xFF;
        node->buffer[node->curPos] = val & 0xFF;
    }
    node->curPos += 3;
    node->first->totalLen += 3;
}

void writebufferInt16(SerializeBuffer * node, uint16_t val, int endianness)
{
    memcpy((void *) &(node->buffer[node->curPos]), (void *) &val, 2);
    if (((END_ORDER == LITTLE_END) && (endianness == BIGENDIAN)) || ((END_ORDER == BIG_END) && (endianness == !BIGENDIAN)))
    {

        uint8_t temp;
        temp = node->buffer[node->curPos];
        node->buffer[node->curPos] = node->buffer[node->curPos+1];
        node->buffer[node->curPos+1] = temp;
    }
    node->curPos += 2;
    node->first->totalLen += 2;
}

void writebufferInt8(SerializeBuffer * node, uint8_t val, int endianness)
{
    (node->buffer[node->curPos]) = val;
    node->curPos += 1;
    node->first->totalLen += 1;
}

void writebufferReal32(SerializeBuffer * node,float val, int endianness)
{
    memcpy((void *) &(node->buffer[node->curPos]), (void *) &val, 4);
    if (((END_ORDER == LITTLE_END) && (endianness == BIGENDIAN)) || ((END_ORDER == BIG_END) && (endianness == !BIGENDIAN)))
    {
        uint8_t temp;
        temp = node->buffer[node->curPos];
        node->buffer[node->curPos] = node->buffer[node->curPos+3];
        node->buffer[node->curPos+3] = temp;

        temp = node->buffer[node->curPos+1];
        node->buffer[node->curPos+1] = node->buffer[node->curPos+2];
        node->buffer[node->curPos+2] = temp;
    }
    node->curPos += 4;
    node->first->totalLen += 4;
}

void writebufferReal64(SerializeBuffer * node, double val, int endianness)
{
     memcpy((void *) &(node->buffer[node->curPos]), (void *) &val, 8);
     if (((END_ORDER == LITTLE_END) && (endianness == BIGENDIAN)) || ((END_ORDER == BIG_END) && (endianness == !BIGENDIAN)))
    {
        uint8_t temp;
        temp = node->buffer[node->curPos];
        node->buffer[node->curPos] = node->buffer[node->curPos+7];
        node->buffer[node->curPos+7] = temp;

        temp = node->buffer[node->curPos+1];
        node->buffer[node->curPos+1] = node->buffer[node->curPos+6];
        node->buffer[node->curPos+6] = temp;

        temp = node->buffer[node->curPos+2];
        node->buffer[node->curPos+2] = node->buffer[node->curPos+5];
        node->buffer[node->curPos+5] = temp;

        temp = node->buffer[node->curPos+3];
        node->buffer[node->curPos+3] = node->buffer[node->curPos+4];
        node->buffer[node->curPos+4] = temp;
    }
    node->curPos += 8;
    node->first->totalLen += 8;
}

void writebufferOctetStr(SerializeBuffer * node, unsigned char * val, int len, int endianness) {
     memcpy((void *) &(node->buffer[node->curPos]), (void *) val, len);
    node->curPos += len;
    node->first->totalLen += len;
}

SerializeBuffer * writeNulls(SerializeBuffer * node, unsigned long len){
   if ((node = SerializeBufferAllocate(node, len)) == NULL){
       return NULL;
   }
   for (unsigned long i = 0; i < len; i++){
        node->buffer[node->curPos++] = '\0';
   }
   node->first->totalLen += len;
   return node;
}



uint8_t * combineBuffers(SerializeBuffer * node, unsigned long* length){
    //add up curr pos to find out how long it is. allocate memory of that length and copy it in

     //check for NULL and throw print and exit. this means there is no buffers to combine
    if(node == NULL){
        fprintf(stderr,"Error... nothing to combine");
	return NULL;
    }

    //now that we have the total length, allocate memory
    //printf("allocaing %lu bytes\n", node->first->totalLen);
    uint8_t * totalBuffer = (uint8_t*) malloc(node->first->totalLen);

    //create list pointer
    SerializeBuffer * pointer = node->first;
    int curPos = 0;
    while(pointer != NULL){
	//fprintf(traceFileParser,"\ncopying %d bytes at pos %d\n", pointer->curPos, curPos);
	memcpy((void *) totalBuffer+curPos, (void *) pointer->buffer, pointer->curPos);
	curPos += pointer->curPos;
	pointer = pointer -> next;
    }

    // loop to add each of the buffers to the main buffer.
    *length = node->first->totalLen;
    return totalBuffer;
}

void freeBuffers(SerializeBuffer * node){
    SerializeBuffer *tmp, *rover = node->first;
    while(rover != NULL){
       tmp = rover;
       if (tmp -> buffer != NULL) free(tmp->buffer);
       tmp -> buffer = NULL;
       rover = rover-> next;
       free (tmp);
    }
}

/// print utilities also in serialize
void printOctetStr(FILE * pf, char * name, unsigned char * val, int len, unsigned int indent, int index){
    fprintf(pf, "%*c%s", indent, ' ', name);
    if (index >= 0){
       fprintf(pf,"(%d)",index);
    }
    fprintf(pf, " OCTET STR");
    // check if all characgters are printable
    bool print = true;
    for (int i = 0; i < len; i++){
	if (val[i] < 32 || val[i] > 126) print = false;
    }
    if (print){
        fprintf(pf," a\"");
	for (int i = 0; i < len; i++){
	    fputc(val[i],pf);
	}
    } else {
        fprintf(pf," x\"");
	for (int i = 0; i < len; i++){
	    fprintf(pf,"%02x",val[i]);
	}
    }
    fprintf(pf,"\"\n");
}

